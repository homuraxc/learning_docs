postgresql 中的视图和物化视图都可以创建索引？



这个问题问得非常好 👍。我来分开解释 PostgreSQL 中 **视图 (VIEW)** 和 **物化视图 (MATERIALIZED VIEW)** 与索引的关系：



------





## **1. 普通视图 (VIEW)**





-   **视图** 本质上是一个 **保存下来的查询语句定义**（query definition）。

-   当你 SELECT 一个视图时，PostgreSQL 会把视图的 SQL 展开（inline）到查询里执行。

-   因为视图不存储实际数据，所以：

    

    -   **视图本身不能创建索引**。
    -   但如果视图依赖的 **基础表** 上有索引，优化器在展开查询时仍然可以利用那些索引。

    





📌 举例：

```
CREATE VIEW active_users AS
SELECT id, name FROM users WHERE status = 'active';

-- ❌ 不支持：
CREATE INDEX idx_active_users ON active_users(name); 
-- 会报错：不能在视图上建索引
```

👉 但是在 users 表上建索引：

```
CREATE INDEX idx_users_status ON users(status);
```

查询视图时，优化器会利用这个索引。



------





## **2. 物化视图 (MATERIALIZED VIEW)**





-   **物化视图** 会把查询结果真正存储在磁盘上，相当于一个“持久化的临时表”。

-   因为它有实际数据文件，所以：

    

    -   ✅ **物化视图可以创建索引**，就像普通表一样。
    -   查询物化视图时，可以用这些索引加速查询。

    





📌 举例：

```
CREATE MATERIALIZED VIEW mv_active_users AS
SELECT id, name FROM users WHERE status = 'active';

-- ✅ 可以在物化视图上建索引
CREATE INDEX idx_mv_active_users_name ON mv_active_users(name);
```

⚠️ 但要注意：



-   物化视图不会自动更新，底层表变化时需要手动 REFRESH MATERIALIZED VIEW。
-   刷新时，相关索引不会丢失，会继续可用。





------





## **3. 总结对比**



| **特性** | **普通视图 (VIEW)**            | **物化视图 (MATERIALIZED VIEW)** |
| -------- | ------------------------------ | -------------------------------- |
| 数据存储 | 不存数据，只保存 SQL           | 存储查询结果                     |
| 索引支持 | ❌ 不能直接建索引               | ✅ 可以建索引                     |
| 性能     | 查询时动态展开，依赖底层表索引 | 查询直接用物化结果，可用索引加速 |
| 更新     | 实时，自动反映表数据变化       | 手动 REFRESH 更新                |



------



📌 **结论**：



-   **视图不能直接创建索引**，但依赖表的索引仍然有效。
-   **物化视图可以直接创建索引**，常用于加速复杂查询的结果集。





------



要不要我给您写一个 **实战示例**：在大表上做聚合查询 → 用物化视图 + 索引优化 → 对比查询速度？