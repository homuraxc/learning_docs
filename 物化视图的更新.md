何时使用REFRESH MATERIALIZED VIEW ，请举例



好问题 👍。**REFRESH MATERIALIZED VIEW** 是 PostgreSQL 中用来 **更新物化视图数据** 的命令，因为物化视图不会像普通视图一样实时反映底层表的变化。



------





## **1. 什么时候要用** 

## **REFRESH MATERIALIZED VIEW**





-   当 **底层表的数据已经变化**，而你希望物化视图中的内容也更新时。

-   特别适合：

    

    1.  **复杂聚合/汇总查询**：比如统计报表，底层表有千万行数据，每次查询都要聚合，非常慢 → 可以用物化视图存储结果，定期刷新。
    2.  **需要索引的查询结果**：普通视图不能建索引，物化视图可以，适合经常查询某个结果集。
    3.  **报表系统**：日报、周报、月报这种场景，可以定时刷新，而不是实时更新。

    





------





## **2. 用法示例**







### **(1) 创建物化视图**





假设有一个订单表：

```
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INT,
    amount NUMERIC,
    created_at TIMESTAMP DEFAULT now()
);
```

创建一个物化视图，统计每个客户的消费总额：

```
CREATE MATERIALIZED VIEW customer_sales AS
SELECT customer_id, SUM(amount) AS total_spent
FROM orders
GROUP BY customer_id;
```

此时，customer_sales 保存了快照。



------





### **(2) 底层表数据发生变化**





插入新订单：

```
INSERT INTO orders (customer_id, amount) VALUES (1, 200);
INSERT INTO orders (customer_id, amount) VALUES (2, 150);
```

此时：

```
SELECT * FROM customer_sales;
```

结果 **不会包含刚插入的数据**。



------





### **(3) 刷新物化视图**





使用：

```
REFRESH MATERIALIZED VIEW customer_sales;
```

再查询：

```
SELECT * FROM customer_sales;
```

结果就会更新，包含最新的订单数据。



------





## **3. 性能优化**





-   默认 REFRESH MATERIALIZED VIEW 会锁表，阻塞读写。
-   PostgreSQL 9.4+ 支持：



```
REFRESH MATERIALIZED VIEW CONCURRENTLY customer_sales;
```



-   

    -   在刷新时允许并发查询（但要求物化视图上有唯一索引）。

    





------





## **4. 总结**





-   **普通视图** = 实时结果，不需要刷新。
-   **物化视图** = 快照，需要 **手动/定时 REFRESH**。
-   **典型使用场景**：报表统计、复杂聚合、加速频繁使用但不需要实时更新的数据查询。





------



要不要我帮您写一个 **定时任务方案**（比如用 cron 或 pgAgent 每天凌晨刷新物化视图），适合报表场景？