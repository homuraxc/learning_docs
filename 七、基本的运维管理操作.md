# 七、基本的运维管理操作



## 1. 角色（Role）



PostgreSQL 有一个称为“角色”的概念。角色（数据库角色）是指可以拥有数据库对象并对数据库具有权限的实体。角色可以定义为单个用户、一个用户组，或者两者的结合。



在多数情况下，“用户”和“角色”是同义使用的，但如果区分使用时，由多个用户组成的集合被称为“角色”，单个用户则称为“用户”。利用角色，可以像对待单一用户一样管理多个用户。



一个数据库集群中不能创建重名的角色。



PostgreSQL 的用户账户是以数据库集群为单位创建的。因此，与在各个数据库中创建的表不同，这些用户账户在该数据库集群中的所有数据库中是共享的。



管理数据库角色的 SQL 命令包括 CREATE ROLE / CREATE USER、ALTER ROLE / ALTER USER 和 DROP ROLE / DROP USER。



这些命令只能由超级用户或具有 CREATEROLE 权限（创建用户的权限）的用户执行。如果要创建新的超级用户，必须以超级用户身份连接数据库。



### 1.1 CREATE ROLE / CREATE USER



创建数据库角色的命令。

```
CREATE ROLE 角色名 [WITH] [属性];
CREATE USER 角色名 [WITH] [属性];
```



**常用属性**

| **属性**        | **说明**                                                     |
| --------------- | ------------------------------------------------------------ |
| [NO]LOGIN       | 设置是否拥有登录数据库集群的权限。CREATE ROLE语法：默认值为NOLOGIN（无登录权限）CREATE USER语法：默认值为LOGIN（有登录权限） |
| [NO]SUPERUSER   | 设置是否拥有超级用户权限。默认值为NOSUPERUSER（无超级用户权限） |
| [NO]CREATEDB    | 设置是否拥有创建数据库的权限。默认值为NOCREATEDB（无创建数据库权限） |
| [NO]CREATEROLE  | 设置是否拥有创建角色（用户）的权限。默认值为NOCREATEROLE（无创建角色权限） |
| PASSWORD ‘密码’ | 设置连接数据库时使用的密码                                   |
| IN ROLE 角色名  | 设置要作为成员添加的已有角色名                               |



**示例**

```bash
$ psql -U postgres
psql (11.1)
Type "help" for help.

postgres=# \l
                                List of databases
   Name     |  Owner   | Encoding | Collate | Ctype | Access privileges 
------------+----------+----------+---------+-------+-------------------
 postgres   | postgres | UTF8     | C       | C     | 
 template0  | postgres | UTF8     | C       | C     | =c/postgres         +
            |          |          |         |       | postgres=CTc/postgres
 template1  | postgres | UTF8     | C       | C     | =c/postgres         +
            |          |          |         |       | postgres=CTc/postgres
(3 rows)

postgres=# CREATE ROLE test LOGIN CREATEDB PASSWORD 'pass001';  ← 创建 test 用户
CREATE ROLE
postgres=# \q

$ psql -U test postgres     ← 使用 test 用户登录
psql (11.1)
Type "help" for help.

postgres=> CREATE DATABASE testdb;    ← 使用 test 用户创建数据库
CREATE DATABASE
postgres=> \l
                                List of databases
   Name     | Owner | Encoding | Collate | Ctype | Access privileges 
------------+--------+----------+---------+-------+-------------------
 postgres   | postgres | UTF8   | C       | C     | 
 template0  | postgres | UTF8   | C       | C     | =c/postgres         +
            |          |        |         |       | postgres=CTc/postgres
 template1  | postgres | UTF8   | C       | C     | =c/postgres         +
            |          |        |         |       | postgres=CTc/postgres
 testdb     | test     | UTF8   | C       | C     | 
(4 rows)
```



### 1.2 ALTER ROLE / ALTER USER

用于更改数据库角色的命令。

**设置属性**

```
ALTER ROLE 角色名 [WITH] [属性];
ALTER USER 角色名 [WITH] [属性];
```

※ 属性与 CREATE ROLE / CREATE USER 命令相同。



**更改角色名**

```
ALTER ROLE 当前角色名 RENAME TO 新角色名;
ALTER USER 当前角色名 RENAME TO 新角色名;
```



##### **示例**

```bash
postgres=# \du    ← 确认当前的用户信息
                                   List of roles
 Role name |                 Attributes                 | Member of 
-----------+--------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB,         | {}
           | Replication, Bypass RLS                    | 
 test      | Create DB                                  | {}
 user01    | Superuser                                  | {}

postgres=# ALTER ROLE test CREATEROLE;    ← 给 test 用户赋予角色创建权限
ALTER ROLE

postgres=# \du    ← 确认 test 用户已被赋予角色创建权限
                                   List of roles
 Role name |                 Attributes                 | Member of 
-----------+--------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB,         | {}
           | Replication, Bypass RLS                    | 
 test      | Create role, Create DB                     | {}
 user01    | Superuser                                  | {}
```



### 1.3 DROP ROLE / DROP USER

用于删除数据库角色的命令。

```
DROP ROLE 角色名;
DROP USER 角色名;
```



**示例**

```bash
postgres=# \du    ← 确认当前的用户信息
                                   List of roles
 Role name |                 Attributes                 | Member of 
-----------+--------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB,         | {}
           | Replication, Bypass RLS                    | 
 test      | Create role, Create DB                     | {}
 user01    | Superuser                                  | {}

postgres=# DROP ROLE test;    ← 删除 test 用户
DROP ROLE

postgres=# \du    ← 确认 test 用户已被删除
                                   List of roles
 Role name |                 Attributes                 | Member of 
-----------+--------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB,         | {}
           | Replication, Bypass RLS                    | 
 user01    | Superuser                                  | {}
```



[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「CREATE ROLE」：パラメータ](https://www.postgresql.jp/document/14/html/sql-createrole.html#id-1.9.3.78.6)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「CREATE ROLE」](https://www.postgresql.jp/document/14/html/sql-createrole.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「ALTER ROLE」](https://www.postgresql.jp/document/14/html/sql-alterrole.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「ALTER USER」](https://www.postgresql.jp/document/14/html/sql-alteruser.html)

[Let'sプログラミング「ロールの作成」](https://www.javadrive.jp/postgresql/role/index2.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「DROP ROLE」](https://www.postgresql.jp/document/14/html/sql-droprole.html)

[Let'sプログラミング「ロールの削除」](https://www.javadrive.jp/postgresql/role/index5.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「DROP USER」](https://www.postgresql.jp/document/14/html/sql-dropuser.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「第22章 データベースロール」](https://www.postgresql.jp/document/14/html/user-manag.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「22.2. ロールの属性」](https://www.postgresql.jp/document/14/html/role-attributes.html)

------

## 2. 权限管理

用于权限管理的 SQL 命令主要有 GRANT 和 REVOKE。



### 2.1 GRANT

用于赋予权限的命令。

```
GRANT 权限 ON 表名 TO {用户名 | PUBLIC};
GRANT 权限 ON DATABASE 数据库名 TO {用户名 | PUBLIC};
GRANT 权限 ON SCHEMA 模式名 TO {用户名 | PUBLIC};
```



**常用权限说明**

| **权限**   | **对象类型** | **含义**                               |
| ---------- | ------------ | -------------------------------------- |
| ALL        | 表           | 授予所有权限                           |
| SELECT     | 表           | 允许执行 SELECT 和 COPY TO             |
| INSERT     | 表           | 允许执行 INSERT 和 COPY FROM           |
| UPDATE     | 表           | 允许执行 UPDATE                        |
| DELETE     | 表           | 允许执行 DELETE                        |
| TRUNCATE   | 表           | 允许执行 TRUNCATE（快速删除全部数据）  |
| REFERENCES | 表           | 允许创建外键约束                       |
| TRIGGER    | 表           | 允许创建触发器                         |
| CONNECT    | 数据库       | 允许连接数据库                         |
| CREATE     | 数据库/模式  | 允许在数据库创建模式或在模式中创建对象 |



**常用参数**

-   PUBLIC：表示对所有用户赋予权限



**示例**

```bash
testdb=# \z item    ← 确认 item 表的权限

                    Access privileges

 Schema | Name | Type  | Access privileges           | Column privileges | Policies 
--------+------+-------+-----------------------------+-------------------+----------
 public | item | table | postgres=arwdDxt/postgres+  |                   | 
        |      |       | user1=arw/postgres          |                   | 
(1 row)

testdb=# GRANT SELECT, INSERT, UPDATE, DELETE ON item TO user2;    ← 给 user2 用户赋予权限
GRANT
testdb=# \z item    ← 确认 item 表的权限
                    Access privileges

 Schema | Name | Type  | Access privileges           | Column privileges | Policies 
--------+------+--------+-----------------------------+-------------------+----------
 public | item | table | postgres=arwdDxt/postgres  +|                   | 
        |      |       | user1=arw/postgres         +|                   | 
        |      |       | user2=arwd/postgres         |                   | 
(1 row)
```

使用 \z（或 \dp）查看权限分配结果，可从“Access privileges”栏读取：



用户名=被赋予的权限/授权者的用户名
例：postgres=arwdDxt/postgres



若授权对象为所有用户（PUBLIC），用户名将省略：
例：=arwdDxt/postgres



权限缩写说明：

-   r：SELECT
-   w：UPDATE
-   a：INSERT
-   d：DELETE
-   D：TRUNCATE
-   x：REFERENCES
-   t：TRIGGER
-   arwdDxt：全部权限



### 2.2 REVOKE

用于撤销权限的命令。

```
REVOKE 权限 ON 表名 FROM {用户名 | PUBLIC};
REVOKE 权限 ON DATABASE 数据库名 FROM {用户名 | PUBLIC};
REVOKE 权限 ON SCHEMA 模式名 FROM {用户名 | PUBLIC};
```

※ 权限以及常用的参数都与 GRANT 相同。



**示例**

```bash
testdb=# \z item    ← 确认 item 表的权限

                    Access privileges

 Schema | Name | Type  | Access privileges           | Column privileges | Policies 
--------+------+--------+-----------------------------+-------------------+----------
 public | item | table | postgres=arwdDxt/postgres+  |                   | 
                      | user1=arw/postgres           |                   | 
                      | user2=arwd/postgres          |                   | 
(1 row)

testdb=# REVOKE INSERT, UPDATE ON item FROM user1;    ← 撤销 user1 用户的部分权限
REVOKE

testdb=# \z item    ← 确认 item 表的权限

                    Access privileges

 Schema | Name | Type  | Access privileges           | Column privileges | Policies 
--------+------+--------+-----------------------------+-------------------+----------
 public | item | table | postgres=arwdDxt/postgres+  |                   | 
                      | user1=r/postgres             |                   | 
                      | user2=arwd/postgres          |                   | 
(1 row)
```

使用 \z（或 \dp）查看权限分配结果的方法与 GRANT 命令相同。



[LPI-JAPAN OSS-DB OSS-DB道場「第16回　権限管理」](https://oss-db.jp/dojo/dojo_16)

[Let'sプログラミング「ユーザーに権限を設定する(GRANT文)」](https://www.javadrive.jp/mysql/user/index6.html)

[Let'sプログラミング「ユーザーに設定できる権限の種類と一覧」：権限の一覧](https://www.javadrive.jp/mysql/user/index5.html#section2)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「GRANT」](https://www.postgresql.jp/document/14/html/sql-grant.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「REVOKE」](https://www.postgresql.jp/document/14/html/sql-revoke.html)



------

## 3. Vacuum 及统计信息的收集



PostgreSQL 采用一种机制，在执行更新操作时会将更新前的数据保留在数据文件中。这种机制称为 MVCC（Multi-Version Concurrency Control，多版本并发控制）。

其目的是在面对多个用户同时访问同一数据时，使查询操作与更新操作能够并行进行。

因此，如果不对数据文件进行整理并持续运行系统，由更新操作产生的未再使用的数据（即无用区域）将逐渐增加，从而导致文件大小超过实际数据量。



【MVCC 的示意图】

```
┌──────────────────────────── PostgreSQL MVCC 一览图 ─────────────────────────────┐
│                         多个事务同时访问/修改同一行记录                             │
└────────────────────────────────────────────────────────────────────────────────┘

【初始状态】
  事务还未开始，表中存在一条记录：

    table1
    +----+--------+
    | id | name   |
    +----+--------+
    | 1  | Alice  |  ← 原始记录
    +----+--------+

───────────────────────────────────────────────────────────────────────────────

【步骤①】事务A开始读取数据：

    BEGIN;                    ← 事务A开始
    SELECT * FROM table1;    ← 读取数据
    
    ➤ 事务A看到的结果：Alice

───────────────────────────────────────────────────────────────────────────────

【步骤②】事务B同时对数据进行更新：

    BEGIN;                              ← 事务B开始
    UPDATE table1 SET name='Bob'        ← 修改数据
    
    ➤ PostgreSQL 并不直接覆盖，而是创建“新版本”：
    
    table1（物理结构）：
    +----+--------+--------+--------+
    | id | name   | xmin   | xmax   |
    +----+--------+--------+--------+
    | 1  | Alice  | 100    | 102    |  ← 原始版本（事务100插入，事务102废弃）
    | 1  | Bob    | 102    |        |  ← 新版本（事务102插入）
    +----+--------+--------+--------+

说明：
	•	xmin: 插入该行的事务ID
	•	xmax: 删除该行的事务ID（被新版本替代）

───────────────────────────────────────────────────────────────────────────────

【步骤③】事务A继续读取数据：

    SELECT * FROM table1;
    
    ➤ 事务A仍然看到旧版本：Alice
       因为在事务A开始时，事务B还未提交（MVCC隔离）

───────────────────────────────────────────────────────────────────────────────

【步骤④】事务B提交：

    COMMIT;     ← 事务B结束并提交更改

───────────────────────────────────────────────────────────────────────────────

【步骤⑤】事务A提交后重新开始，再次读取：

    COMMIT;                       ← 事务A结束
    BEGIN;
    SELECT * FROM table1;
    
    ➤ 现在事务A看到的是新版本：Bob

───────────────────────────────────────────────────────────────────────────────

【总结】
✔ PostgreSQL 会保留每次更新前后的数据版本
✔ 不同事务根据开始时间看到不同版本（隔离性保障）
✔ 旧版本不会自动删除，需靠 VACUUM 机制定期清理
✔ 避免锁冲突，提高并发性

───────────────────────────────────────────────────────────────────────────────
```



由于数据文件的膨胀会造成性能下降，因此有必要定期整理无用区域。

此外，为了更高效地执行 SQL，还建议定期更新用于查询优化的统计信息。



在 PostgreSQL 中，用于整理无用区域与统计信息的 SQL 命令主要包括：

VACUUM、ANALYZE、REINDEX、CLUSTER。

若省略表名，则会对数据库中的所有表执行处理。以下是各命令的详细说明：



### 3.1 VACUUM

该命令用于回收包含索引在内的无用区域。

所谓“回收无用区域”，是指将不再使用的空间标记出来，以便后续重新利用。

执行 Vacuum 时，要求对目标表或数据库具有所有者权限。



**语法**

```
VACUUM [选项] [表名[, 表名...]];
```



**【VACUUM 命令的主要选项】**

| **选项** | **说明**                                                     |
| -------- | ------------------------------------------------------------ |
| FULL     | 回收不必要区域，并从OS中删除已回收的区域。命令执行期间会对表施加排他锁（禁止其他用户访问目标数据的控制） |
| ANALYZE  | 回收不必要区域，并进行统计信息的收集与更新                   |



**示例**

```sql
examdb=# VACUUM FULL table1;
VACUUM
```



### 3.2 vacuumdb

虽然 VACUUM 命令通常在已连接数据库的状态下执行，但也可以通过操作系统命令行执行 vacuumdb 命令来回收无用区域。



**语法**

```
vacuumdb [连接选项] [选项] [-t 表名] [数据库名]
```



**【主要连接选项】**

如果未指定选项，则使用环境变量；若环境变量未设置，则采用默认值。

| **连接选项**      | **说明**                                           | **环境变量** | **默认值**     |
| ----------------- | -------------------------------------------------- | ------------ | -------------- |
| -U 用户名         | 指定连接时的数据库用户名                           | PGUSER       | OS用户名       |
| -h 主机名或IP地址 | 指定连接目标的主机名或IP地址支持TCP/IP和UNIX域连接 | PGHOST       | 使用UNIX域连接 |
| -d 数据库名       | 指定连接目标的数据库名称                           | PGDATABASE   | 数据库用户名   |
| -p 端口名         | 指定连接目标的端口号                               | PGPORT       | 5432           |



**【主要选项】**

| **选项**            | **说明**                                                     |
| ------------------- | ------------------------------------------------------------ |
| –all \| -a          | 将所有数据库作为回收不必要区域的对象                         |
| –full \| -f         | 回收不必要区域，并从OS中删除已回收的区域命令执行期间对表施加排他锁（禁止其他用户访问目标数据的控制） |
| –analyze \| -z      | 回收不必要区域，并进行统计信息的收集与更新                   |
| –analyze-only \| -Z | 不回收不必要区域，仅进行统计信息的收集与更新                 |



**示例**

```bash
$ vacuumdb -az     ← 对所有数据库执行不需要区域的回收与统计信息的收集与更新
vacuumdb: vacuuming database "examdb"
vacuumdb: vacuuming database "postgres"
vacuumdb: vacuuming database "template1"
vacuumdb: vacuuming database "test"
```





### 3.3 ANALYZE

该命令用于收集并更新统计信息。

若统计信息与实际数据存在较大差异，SQL 执行计划将无法正确生成。



**语法**

```
ANALYZE [表名[, 表名...]];
```



**执行示例**

```sql
examdb=# ANALYZE table1;
ANALYZE
```





### 3.4 REINDEX

该命令重新构建索引，以清除索引中产生的空白区域。



**语法**

```
REINDEX [选项];
```



**【REINDEX 命令的主要选项】**

-   INDEX 索引名：重新构建指定索引
-   TABLE 表名：重新构建指定表中的所有索引



**执行示例**

```sql
examdb=# REINDEX TABLE table1;
REINDEX
```



### 3.5 CLUSTER

该命令根据索引对表中的数据进行物理排序，

从而提升数据检索的效率。



**语法**

```
CLUSTER 表名 [USING 索引名];
```



**执行示例**

```sql
examdb=# CLUSTER table1 USING test_index;
CLUSTER
```



此外，PostgreSQL 还提供名为「自动 Vacuum（autovacuum）」的功能。

该功能会自动执行无用区域的回收（VACUUM）和统计信息的收集与更新（ANALYZE）。



可通过 autovacuum 参数启用（on）或禁用（off）该功能，自 PostgreSQL 8.3 起默认值为 on。

此参数在 PostgreSQL 启动/重启或重新加载 postgresql.conf 文件后生效。



自动 Vacuum 会通过多个进程处理大量数据更新的表。

在更新频繁的系统中，除了自动 Vacuum 外，可能还需要手动执行 VACUUM 命令以维持性能。



[日本PostgreSQLユーザ会 PostgreSQL14.5文書「20.10. 自動Vacuum作業」：autovacuum](https://www.postgresql.jp/document/14/html/runtime-config-autovacuum.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「vacuumdb」](https://www.postgresql.jp/document/14/html/app-vacuumdb.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「VACUUM」](https://www.postgresql.jp/document/14/html/sql-vacuum.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「25.1. 定常的なバキューム作業」：25.1.6. 自動バキュームデーモン](https://www.postgresql.jp/document/14/html/routine-vacuuming.html#AUTOVACUUM)

[LPI-JAPAN OSS-DB OSS-DB入門「第10回　パフォマンス・チューニング(後編)」：バキューム処理、統計情報の収集](https://oss-db.jp/dojo/dojo_info_10)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「ANALYZE」](https://www.postgresql.jp/document/14/html/sql-analyze.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「CLUSTER」](https://www.postgresql.jp/document/14/html/sql-cluster.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「REINDEX」](https://www.postgresql.jp/document/14/html/sql-reindex.html)



------

## 4. 信息模式

关于数据库集群的信息可以通过“信息模式”和“系统目录”来确认。它们各自的特点如下所示。



### 4.1 信息模式

信息模式是包含数据库对象定义信息的模式（在数据库中用于存放表等对象的命名空间）。



其特点如下：



-   模式的名称为 information_schema
-   遵循 SQL 的标准规范，具有良好的可移植性
-   是一组视图（根据 SQL 的 SELECT 结果定义的虚拟表）和表的集合
-   属于在创建数据库集群时生成的超级用户
-   查询时不需要特别的设置或权限





信息模式中的主要视图

-   tables

    包含所有表和视图的列表，包括默认创建的 public 模式内的对象。



示例命令：

```sql
examdb=# SELECT * FROM information_schema.tables;

-- ～省略～

 table_catalog | table_schema    | table_name       | table_type | self_referencing_column_name | is_insertable_into | is_typed | commit_action 
---------------+-----------------+------------------+------------+-------------------------------+---------------------+----------+----------------
 examdb        | pg_catalog      | pg_statistic     | BASE TABLE |                               | YES                 | NO       | 
 examdb        | pg_catalog      | pg_type          | BASE TABLE |                               | YES                 | NO       | 
 examdb        | public          | table1           | BASE TABLE |                               | YES                 | NO       | 
 examdb        | pg_catalog      | pg_shadow        | VIEW       |                               | NO                  | NO       | 
...
 examdb        | pg_catalog      | pg_auth_members  | BASE TABLE |                               | YES                 | NO       | 
 examdb        | information_schema | sql_features  | BASE TABLE |                               | YES                 | NO       | 
(178 rows)
```





### 4.2 系统目录

系统目录是 PostgreSQL 特有的表，用于存储数据库的内部信息。

其特点如下：



-   Schema 名称为 pg_catalog（自动包含在搜索路径中，因此可以省略模式名）
-   用于查看比信息模式更详细的信息
-   包含关于数据库集群管理的信息
-   不遵循 SQL 的标准规范，移植性较低



PostgreSQL 的主要系统目录

| 名称        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| pg_tables   | 存储数据库中关于表的信息，例如模式名、表名、所有者、是否有索引等 |
| pg_database | 存储数据库集群整体中的数据库信息，如数据库名、所有者、编码方式等 |
| pg_user     | 存储数据库集群所有用户的信息，如用户名、用户ID、权限等       |
| pg_authid   | 存储数据库集群所有角色的信息，如角色名、角色权限、加密密码等 |
| pg_indexes  | 存储数据库中索引的信息，如拥有索引的模式名、表名、索引名等   |



示例

```bash
examdb=# SELECT * FROM pg_tables;

-- ～省略～

 schemaname      | tablename         | tableowner | tablespace | hasindexes | hasrules | hastriggers | rowsecurity 
-----------------+-------------------+------------+------------+------------+----------+-------------+--------------
 pg_catalog      | pg_statistic      | postgres   |            | t          | f        | f           | f
 pg_catalog      | pg_type           | postgres   |            | t          | f        | f           | f
 public          | table1            | user       |            | f          | f        | f           | f
 pg_catalog      | pg_authid         | postgres   | pg_global  | t          | f        | f           | f
...
 pg_catalog      | pg_auth_members   | postgres   | pg_global  | t          | f        | f           | f
 information_schema | sql_features   | postgres   |            | f          | f        | f           | f
(63 rows)
```



[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「第34章 情報スキーマ」](https://www.postgresql.jp/document/14/html/information-schema.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「第52章 システムカタログ」](https://www.postgresql.jp/document/14/html/catalogs.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「50.81. pg_user」](https://www.postgresql.jp/document/14/html/view-pg-user.html)

[LPI-JAPAN OSS-DB サンプル問題／例題解説「001_Silverの例題解説「運用管理」」： Q1.16](https://oss-db.jp/sample/silver_management_01)

[LPI-JAPAN OSS-DB サンプル問題／例題解説「003_Silverの例題解説「運用管理」」： Q1.53](https://oss-db.jp/sample/silver_management_03)

------

## 5. 系统信息函数



PostgreSQL 提供了获取日期、时间和系统信息的函数。获取日期和时间的函数被称为“日期时间函数”，而获取系统信息的函数被称为“系统信息函数”。

以下是主要函数：



### 5.1 系统信息函数

| 函数               | 说明                           |
| ------------------ | ------------------------------ |
| version()          | 获取当前运行中的PostgreSQL版本 |
| current_database() | 获取当前连接的数据库信息       |
| current_user       | 获取执行命令的用户信息         |



### 5.2 日期时间函数

| 函数                  | 说明                       | 返回类型    |
| --------------------- | -------------------------- | ----------- |
| now()                 | 返回当前事务的开始日期时间 | TIMESTAMP型 |
| current_timestamp     | 返回当前事务的开始日期时间 | TIMESTAMP型 |
| statement_timestamp() | 返回当前语句的开始日期时间 | TIMESTAMP型 |
| clock_timestamp()     | 返回实际的当前时间         | TIMESTAMP型 |
| current_date          | 返回当前事务的开始日期     | DATE型      |
| current_time          | 返回当前事务的开始时间     | TIME型      |



**示例**

```sql
examdb=# SELECT version();

                                              version
------------------------------------------------------------------------------------------------------
 PostgreSQL 9.6.5 on x86_64-apple-darwin15.6.0, compiled by Apple LLVM version 8.0.0 (clang-800.0.42.1), 64-bit
(1 row)

examdb=# SELECT current_database();
current_database
------------------
 examdb
(1 row)


examdb=# SELECT current_user;
 current_user
--------------
 postgres
(1 row)

```



[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「9.26. システム情報関数」](https://www.postgresql.jp/document/14/html/functions-info.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「9.9. 日付/時刻関数と演算子」：表9.32 日付/時刻関数演算子](https://www.postgresql.jp/document/14/html/functions-datetime.html#FUNCTIONS-DATETIME-TABLE)

