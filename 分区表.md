介绍下postgresql中可以使用声明式分区创建的分区的类型，及其使用场景。



好问题 👍。PostgreSQL 从 **10 版本开始**支持 **声明式分区 (Declarative Partitioning)**，相比老的继承+触发器方式更简洁。下面我帮您整理 **分区类型** 和 **使用场景**：



------





## **1. 可用的分区类型**





在 CREATE TABLE ... PARTITION BY ... 里可以选择不同分区方法：





### **(1)** 

### **RANGE 分区**





-   按 **范围 (range)** 把数据分区，比如时间区间、数值区间。
-   语法：



```
CREATE TABLE sales (
    id serial,
    sale_date date,
    amount numeric
) PARTITION BY RANGE (sale_date);

CREATE TABLE sales_2024q1 PARTITION OF sales
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');
CREATE TABLE sales_2024q2 PARTITION OF sales
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');
```



-   

-   **使用场景**：

    

    -   按时间维度存储业务数据（日志、订单、监控数据）。
    -   查询常常带时间范围条件，比如 WHERE sale_date BETWEEN ...。

    





------





### **(2)** 

### **LIST 分区**





-   按 **枚举值集合** 分区。
-   语法：



```
CREATE TABLE customers (
    id serial,
    region text
) PARTITION BY LIST (region);

CREATE TABLE customers_asia PARTITION OF customers
    FOR VALUES IN ('China', 'Japan', 'Korea');
CREATE TABLE customers_europe PARTITION OF customers
    FOR VALUES IN ('France', 'Germany');
```



-   

-   **使用场景**：

    

    -   按地理区域、部门、类型分类存储。
    -   查询条件通常是 WHERE region = 'xxx'。

    





------





### **(3)** 

### **HASH 分区**





-   按 **哈希函数取模** 分区，系统会根据列值的 hash 值分散到不同分区。
-   语法：



```
CREATE TABLE users (
    id int,
    name text
) PARTITION BY HASH (id);

CREATE TABLE users_p0 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 0);
CREATE TABLE users_p1 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 1);
```



-   

-   **使用场景**：

    

    -   数据无法按范围或枚举明显拆分，但需要 **均匀分布**。
    -   典型场景：大规模用户表、交易表，避免单一分区过大。

    





------





### **(4)** 

### **复合分区 (子分区 / 多级分区)**





-   PostgreSQL 11+ 开始支持 **分区表下再分区**。
-   语法：



```
CREATE TABLE sales (
    id serial,
    sale_date date,
    region text
) PARTITION BY RANGE (sale_date);

CREATE TABLE sales_2024 PARTITION OF sales
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01')
    PARTITION BY LIST (region);

CREATE TABLE sales_2024_asia PARTITION OF sales_2024
    FOR VALUES IN ('Asia');
```



-   

-   **使用场景**：

    

    -   先按时间，再按区域；
    -   或先按哈希，再按时间。
    -   特别适合海量数据（PB 级别日志/监控数据）。

    





------





## **2. 使用场景总结**



| **分区类型** | **特点**       | **典型场景**                              |
| ------------ | -------------- | ----------------------------------------- |
| RANGE        | 按范围划分     | 时间序列数据：日志、订单、监控数据        |
| LIST         | 按枚举值划分   | 地区、部门、类别                          |
| HASH         | 按哈希均匀分布 | 高并发写入的大表，无法明确范围划分时      |
| 复合分区     | 多层拆分       | 大规模数据仓库：按时间+区域 / 按哈希+时间 |



------



📌 **总结**



-   **RANGE 分区**：最常见，适合时间序列。
-   **LIST 分区**：适合有限类别。
-   **HASH 分区**：适合高并发、大数据量，保证均衡。
-   **复合分区**：适合超大规模数据，结合多种维度。





------



hash分区设定中的 modulus 和 remainder 怎么理解？



好问题 👍。HASH 分区里的 modulus 和 remainder 是 PostgreSQL 用来确定 **某行数据到底落到哪个分区** 的两个关键参数。



------





## **1. 概念解释**





-   **modulus（模数）**

    

    -   就是分区的总数量。
    -   PostgreSQL 会用分区键（比如 id）算一个哈希值，然后对 modulus 取模。
    -   结果一定是 0 ~ modulus-1 之间的整数。

    

-   **remainder（余数）**

    

    -   表示当前分区负责接收哪一个模运算的结果。
    -   每个分区的 remainder 都不同，范围在 0 ~ modulus-1。

    





👉 这样就能保证：不同的分区一起覆盖了所有余数，数据会分散到不同分区里。



------





## **2. 举个例子**





假设有一个用户表，按 id 做 **4 个 HASH 分区**：

```
CREATE TABLE users (
    id int,
    name text
) PARTITION BY HASH (id);

CREATE TABLE users_p0 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 0);

CREATE TABLE users_p1 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 1);

CREATE TABLE users_p2 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 2);

CREATE TABLE users_p3 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 3);
```

过程：



1.  PostgreSQL 会计算 hash(id)（一个大整数）。
2.  再算：hash(id) % 4（因为 modulus=4）。
3.  结果如果是 0 → 放到 users_p0，结果是 1 → 放到 users_p1，以此类推。





------





## **3. 类比理解**





-   modulus 就像分了多少个“桶”。
-   remainder 就是“这一号桶接收的编号”。
-   每一行数据被哈希后，落在某个桶（分区）里。





------





## **4. 特殊情况**





-   可以只建部分分区，比如：



```
CREATE TABLE users_p0 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 0);

CREATE TABLE users_p1 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 1);
```



-   这样只有 remainder=0 和 remainder=1 的数据有去处，插入其他值会报错。

    所以一般都会覆盖 0 ~ modulus-1 全部 remainder。





------



📌 **总结**：



-   modulus = 总分区数（取模的除数）。
-   remainder = 当前分区负责存储的余数。
-   算法：hash(分区键) % modulus = remainder → 数据就进这个分区。





------



报错ERROR: unique constraint on partitioned table must include all partitioning columns

DETAIL: PRIMARY KEY constraint on table "sales" lacks column "sale_date" which is part of the partition key.



你这条报错的意思是：**在声明式分区表上做唯一约束（含主键）时，约束的列必须覆盖所有分区键列**。

原因是 PostgreSQL 目前没有“全局唯一索引”；分区表上的唯一性是靠**各分区内各自的索引**来保证的。只有当唯一约束包含分区键时，数据库才能把“全局唯一”拆解为“每个分区内唯一”（因为同一分区键值的行会被路由到同一个分区）。否则，相同的唯一键值可能分散在不同分区里，系统无法在插入时检查冲突，于是禁止这种定义。



------





## **典型触发场景**



```
CREATE TABLE sales (
  id BIGINT,
  sale_date DATE,
  amount NUMERIC
) PARTITION BY RANGE (sale_date);

-- 下面这句会报你看到的错误：
ALTER TABLE sales ADD PRIMARY KEY (id);
-- ERROR:  unique constraint on partitioned table must include all partitioning columns
-- DETAIL: PRIMARY KEY ... lacks column "sale_date"
```



------





## **正确的几种改法（择一）**







### **方案 A：把分区键一起放进主键/唯一约束（最常见）**



```
ALTER TABLE sales ADD PRIMARY KEY (sale_date, id);
-- 或者根据查询习惯调整列顺序：PRIMARY KEY (id, sale_date)
```

这样“(sale_date, id)”在**每个分区内**唯一 ⇒ 等同于全局唯一。





### **方案 B：改变分区方式，使唯一列包含分区键**





如果你业务上需要 id 在全库绝对唯一，且经常按 id 访问，可以考虑 **按 id 做 HASH 分区**，就能定义 PRIMARY KEY (id)：

```
CREATE TABLE users (
  id BIGINT PRIMARY KEY,
  name TEXT
) PARTITION BY HASH (id);
-- 再创建子分区：FOR VALUES WITH (modulus N, remainder r)
```



### **方案 C：联合分区（复合分区键）**





若必须按时间分区且又要全局 id 唯一，可以把分区键定义为 **(sale_date, id)**（RANGE/LIST 组合、或 RANGE 再 HASH 子分区），从而满足规则，然后主键同样写 (sale_date, id)。





### **方案 D：放弃“全局强校验”，转为“概率/业务唯一”**





不从数据库层面强制：



-   使用 **UUID** 作为键（碰撞概率极低），只建普通索引；或
-   在**每个分区**上单独建 UNIQUE (id)（只能保证分区内唯一），配合应用侧避免重复。





>   注意：这两种都**不能**让数据库在全局层面硬性保证唯一。



------





## **外键的注意点**





-   若其他表要引用分区表的主键，分区表的 **主键/唯一约束必须包含分区键**（同一条规则）。所以采用“方案 A 或 C”会更顺畅。





------





## **小结**





-   报错的本质：**分区表上的唯一约束必须包含全部分区键**。
-   快速修复：把 sale_date 加进主键/唯一约束；或重选分区策略（如对 id 做 HASH 分区）。
-   不能用“只对 id 建主键 + 按日期 RANGE 分区”的组合。



---

我create table时声明的字段都是分区键是吗？



不是的 🙂。



在 PostgreSQL 里，**分区表的分区键** 需要在 CREATE TABLE ... PARTITION BY ... 语句里 **显式指定**，而不是说你定义的所有字段自动都是分区键。



------





## **1. 定义分区键的方式**





示例：

```
CREATE TABLE sales (
    id bigserial,
    sale_date date NOT NULL,
    amount numeric
) PARTITION BY RANGE (sale_date);
```

这里：



-   表里有三个字段：id, sale_date, amount
-   **只有 sale_date 是分区键**，因为 PARTITION BY RANGE (sale_date) 明确指定了。
-   id 和 amount 都只是普通列。





------





## **2. 分区键和分区表的关系**





-   **分区键**：决定数据路由到哪个分区（partition）。
-   **非分区键列**：正常存储在分区表里，但不影响数据分区。





所以，建表时写的字段不会自动成为分区键，只有在 PARTITION BY (...) 里声明的才是。



------





## **3. 多列分区键**





分区键也可以是多个字段的组合，例如：

```
CREATE TABLE sales (
    id bigserial,
    sale_date date NOT NULL,
    region text NOT NULL,
    amount numeric
) PARTITION BY RANGE (sale_date, region);
```

这里分区键就是 (sale_date, region) 复合键。



------



✅ **结论**：

您在 CREATE TABLE 里定义的字段默认都是普通列，**只有出现在 PARTITION BY (...) 里的字段才是分区键**。



------

“十六进制”格式将二进制数据编码为每个字节2个十六进制位，最高有效位在前。请举例说明这句话的意思。



好的 👍，我来帮您用一个直观的例子解释 **“十六进制格式将二进制数据编码为每个字节 2 个十六进制位，最高有效位在前”** 这句话。



------





## **1. 每个字节 → 二进制表示**





比如我们有一个字节（8 位）：

```
01001010
```



------





## **2. 按 4 位拆分（半字节，nibble）**





把 8 位二进制拆成 **高 4 位** 和 **低 4 位**：

```
0100   1010
 ^^^^   ^^^^
 高位   低位
```



------





## **3. 转换成十六进制**





-   0100 → 十进制 4 → 十六进制 4
-   1010 → 十进制 10 → 十六进制 A





组合起来就是 **4A**。

👉 一个字节 = 两个十六进制字符。



------





## **4. “最高有效位在前”的含义**





-   “最高有效位”指的是 **字节的左边 4 位 (MSB)**，也就是 0100。
-   在十六进制表示时，**先写高 4 位对应的数字**，再写低 4 位。
-   所以写成 4A，而不是 A4。





------





## **5. 再举个例子**





假设我们有二进制数据（2 个字节）：

```
11110000 00001111
```

逐字节转换：



-   11110000 → 高 4 位 = 1111 (F)，低 4 位 = 0000 (0) → F0
-   00001111 → 高 4 位 = 0000 (0)，低 4 位 = 1111 (F) → 0F





组合起来就是十六进制字符串：

```
F00F
```



------



✅ **总结一句**：



-   一个字节（8 位）会被拆成两个 4 位 → 各自转成一个十六进制数字。
-   **先写高 4 位，再写低 4 位**，这就是“最高有效位在前”。
-   例：01001010 (二进制) → 4A (十六进制)。





------



要不要我帮您画一张 **图解示意（8 位 → 4 位 + 4 位 → HEX）**，让这个转换过程更直观？