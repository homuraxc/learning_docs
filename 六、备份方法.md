# 六、备份方法

## 1. 备份

备份是一种机制，用于获取某一时间点的数据库状态，以备发生故障时使用。

还原（Restore）是指将备份的数据文件重新放置。

恢复（Recovery）是指使用备份时获取的数据和随后记录更改的日志，将目标数据恢复到任意时间点的状态。



PostgreSQL 的备份与恢复有如下几种方式：

|                      类型                       | 备份     | 方法                                                         | 恢复方法                                                     |
| :---------------------------------------------: | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|     离线备份<br>（停止 PostgreSQL 后进行）      | 物理备份 | - 使用 tar、rsync 命令等进行目录复制                         | - 配置复制后的目录                                           |
| 在线备份<br>（保持 PostgreSQL 运行状态下进行）  | 物理备份 | - 设置各种参数<br>- 使用 pg_start_backup() 、pg_stop_backup()，以及 tar、rsync 命令等，或 pg_basebackup 命令获取基础备份 | - 配置复制后的目录<br>- 使用未归档但记录了数据库变更的日志（WAL: Write Ahead Logging）<br>- 设置 `postgresql.conf` 文件 |
| 在线备份<br/>（保持 PostgreSQL 运行状态下进行） | 逻辑备份 | - 执行 pg_dump 或 pg_dumpall 命令                            | - 执行 psql 或 pg_restore 命令                               |

-   物理备份：直接使用保存数据库信息的数据文件的备份方式。
-   逻辑备份：关注表结构和数据，以 SQL 文件或二进制文件输出表定义和数据的备份方式。



### 1.1 离线物理备份

离线物理备份是将数据库集群目录物理复制并转移到其他介质上的备份方式。

其特点如下：

-   使用 OS 的标准命令，如 tar 和 rsync 进行操作
    -   tar 命令：创建和展开用于统一管理多个文件的归档文件
    -   rsync 命令：同步另一个位置的目录或文件（支持仅复制差异部分）
-   必须在 PostgreSQL 停止运行的状态下（离线）执行
-   包括 postgresql.conf 等设置文件也是备份对象
-   若操作系统或 PostgreSQL 的主版本不同，基本无法还原
-   除数据库集群目录外，如果还有如表空间（用于存放数据库对象的区域）等数据，也必须包括在备份中
-   可以将数据恢复到取得备份时的状态



#### 示例

备份存放数据库集群的目录。

```bash
$ pg_ctl stop
waiting for server to shut down....done
server stopped
$ cd $PGDATA/..
$ tar cvf backupfile.tar postgres
～省略～  ← 显示被备份目标文件的列表
```



删除备份源目录的状态下执行还原操作。

```bash
$ pg_ctl status    ← 确认PostgreSQL服务器是否已停止
pg_ctl: no server running
$ ls
backupfile.tar  homebrew  log
$ tar xvf backupfile.tar
～省略～  ← 显示要还原的文件列表
$ ls
backupfile.tar  homebrew  log  postgres  ← 显示已还原的postgres文件
$ pg_ctl start
server starting
```



### 1.2 在线物理备份（PITR：Point In Time Recovery）

PITR 是一种利用基础备份（整个数据库的备份）和 PostgreSQL 运行期间生成的 WAL（Write Ahead Logging，即数据库更改日志）进行数据库恢复的方法。WAL 也称为事务日志。



只要取得基础备份后，就可以恢复到发生故障前任意时间点的状态。



用于 PITR 的 WAL 被记录到 WAL 文件中，会持续积累，因此在被删除之前需要将其移动到其他位置保存（归档）。这些被归档的 WAL 文件称为 WAL 归档。



如果归档量巨大，恢复处理将花费较长时间，因此建议定期获取基础备份。重新获取基础备份后，之前的归档文件就变得不再需要，可以被丢弃。



**PITR 的执行流程图**

![image-20250722225604658](/Users/anonymouxc/Library/Application Support/typora-user-images/image-20250722225604658.png)



1.  事前设置
2.  获取基础备份
3.  恢复操作



#### 1.2.1 事前设置

为了避免 WAL 文件被删除，需要将其保存为 WAL 归档。

需在 postgresql.conf 中设置如下参数：

| 参数名          | 说明                                                         | 默认值   |
| --------------- | ------------------------------------------------------------ | -------- |
| wal_level       | 指定在 WAL 中写入信息的详细程度<br>PITR 使用前的准备工作，指定为 replica 或 logical | replica  |
| archive_mode    | 指定是否将 WAL 文件保存为 WAL 归档<br>PITR 使用前的准备工作，指定为 on 或 always | off      |
| archive_command | 指定用于复制 WAL 文件并保存为 WAL 归档的 Shell 命令<br>PITR 使用前的准备工作，指定如下命令<br>示例：'cp %p [WAL 归档的保存路径]/%f' | 空字符串 |



**主要参数的补充说明：**

-   wal_level

    可指定值如下：

    -   minimal：仅含 PostgreSQL 故障或关闭后的恢复所需信息

    -   replica：在 minimal 的基础上增加 WAL 归档及只读查询所需信息

    -   logical：在 replica 的基础上增加逻辑复制所需信息（例如指定表的数据复制）

        注：在 9.6 之前版本中，replica 被替代为 archive 和 hot_standby，这些值会被内部转换为 replica。

    

-   archive_mode

    可指定值如下：

    -   on：启用 WAL 归档
    -   always：在归档恢复或备用模式下也启用归档
    -   off：禁用 WAL 归档

    

-   archive_command

    例子中的 %p 和 %f 会被替换为：

    -   %p：WAL 文件的路径名
    -   %f：WAL 文件的文件名



#### 1.2.2 获取 PITR 的基础备份方法

PostgreSQL 可以在运行状态下进行备份操作。获取基础备份的方法有两种：



1.  使用 pg_start_backup() 和 pg_stop_backup() 函数的方法（称为低级别备份）；
2.  使用 pg_basebackup 命令的方法。



##### 1.2.2.1 使用 pg_start_backup() 和 pg_stop_backup() 函数的方法（低级别备份）

pg_start_backup() 和 pg_stop_backup() 函数是**通知 PostgreSQL 备份开始和结束的函数**。

这两个函数可以妥善管理备份期间，并在备份过程中自动归档生成的 WAL。



pg_start_backup() 函数除了上述处理，还会执行一次检查点操作。检查点是将数据变更同步到磁盘的处理过程。



在 PostgreSQL 中，数据变更时并不会直接更新磁盘上的数据文件，而是先将读取到共享内存一部分的「共享缓冲区（shared buffer）」中的数据进行修改。

之后，通过名为检查点的处理过程，把共享缓冲区中的内容统一写入到磁盘的数据文件中。这样可以提升数据更新时的性能。



通过 pg_start_backup() 函数执行的检查点，会记录下恢复时应适用的 WAL 信息。



执行这些函数需要具备超级用户权限，或者拥有该函数的 EXECUTION 权限（允许执行该函数的权限）。



函数语法如下：

```
pg_start_backup(备份标签名 [, fast模式 [, 排他或非排他]])
```

-   第1个参数（备份标签名）：指定任意的备份标签名。※必填
-   第2个参数（fast模式指定）：指定 true 或 false。设为 true 时，将尽可能使用服务器上可用资源，**立即执行检查点**（默认值为 false）
-   第3个参数（指定排他或非排他）：指定 true 或 false。设为 true 时以“排他模式”执行，设为 false 时以“非排他模式”执行（默认值为 true）



```
pg_stop_backup(排他或非排他 [, 是否等待 WAL 归档处理完成])
```

-   第1个参数：指定 true 或 false。设为 true 时以“排他模式”执行，false 为“非排他模式”。此值需与执行 pg_start_backup 时指定的值一致。
-   第2个参数：指定 true 或 false。设为 true 时，等待 WAL 的归档处理完成；设为 false 时，则不等待 WAL 的归档处理完成。



由于在执行 pg_start_backup() 函数时也包含了检查点的处理，因此可能需要较长时间。

通过将第2个参数设为 true，可以尽可能利用可用资源，尽快完成检查点处理。（默认值为 false）



低层级备份有“非排他模式”和“排他模式”两种方式。

它们各自的特点如下：



**非排他模式**

-   备份获取过程中可以执行其他查询操作。
-   即使正在使用 pg_basebackup 或 pg_start_backup()·pg_stop_backup() 函数进行其他备份，也可以同时执行此备份。
-   pg_start_backup() 函数与 pg_stop_backup() 函数必须在同一个会话内执行。



**排他模式**

-   备份获取过程中无法执行其他查询操作。
-   不能与其他正在进行的备份同时执行。
-   pg_start_backup() 函数与 pg_stop_backup() 函数可以在不同会话中执行。



※低层级备份的排他模式**不推荐使用**，建议使用**非排他模式**执行。

此外，排他模式将来可能会被废除。



以下说明使用“非排他模式”进行低层级备份的步骤。



**步骤**

1.  使用 SELECT 语句调用 pg_start_backup() 函数

    示例：`SELECT pg_start_backup('标签名', false, false);`

2.  对整个数据库集群执行物理备份

3.  使用 SELECT 语句调用 pg_stop_backup() 函数

    示例：`SELECT pg_stop_backup(false);`

4.  根据 pg_stop_backup() 函数的返回值，创建 backup_label 和 tablespace_map 文件，并将它们包含在备份中。



**示例**

```sql
postgres=# SELECT pg_start_backup('Backup01', false, false);  ← 调用开始函数

 pg_start_backup
------------------
 0/27000028
(1 row)

postgres=# \! cp -r $PGDATA ./Backup    ← 获取整个数据库集群的物理备份
postgres=# \! cp -r ./tblspcdir ./Backup ← 获取表空间存储目录的备份

postgres=# SELECT * from pg_stop_backup(false); ← 调用结束函数
NOTICE: all required WAL segments have been archived
    lsn     |                           labelfile                            |          spcmapfile
------------+--------------------------------------------------------------------------------------------------
0/27000138  | START WAL LOCATION: 0/27000028 (file 000000010000027000000027)+|16519  /home/postgres/tblspcdir
            | CHECKPOINT LOCATION: 0/27000060                               +|
            | BACKUP METHOD: streamed                                       +|
            | BACKUP FROM: primary                                          +|
            | START TIME: 2023-06-04 22:28:36 JST                           +|
            | LABEL: Backup01                                               +|
            | START TIMELINE: 1                                             +|
            |                                                                |
(1 row)             ↑ 另存为 backup_label 文件                                       ↑ 另存为 tablespace_map 文件
```



在**非排他模式**下执行 pg_stop_backup() 函数时，会返回用于恢复时所需的信息，即 **labelfile** 和 **spcmapfile**。这些值分别需要作为 backup_label 文件和 tablespace_map 文件创建，并保存在 $PGDATA 目录下。

※ 在恢复时会自动读取这些文件。



另外，在**排他模式**的低级别备份中，在执行 pg_start_backup() 函数时，会自动在 $PGDATA 目录下生成 backup_label 文件和 tablespace_map 文件。

但如果在备份过程中发生故障，这些文件可能会导致 PostgreSQL 服务器之后启动失败。



而在**非排他模式**中，正如前文所述，这些文件是在执行完 pg_stop_backup() 函数后由用户手动创建的，因此不会发生上述问题。



##### 1.2.2.2 使用 pg_basebackup 命令

pg_basebackup 是在 PostgreSQL 9.1 版本中新增的用于获取基础备份的命令。

该命令用于 PITR（时间点恢复）和流复制（将整个数据库集群作为对象进行复制）的场景中。



由于它会备份整个数据库集群，因此也会包含设置文件和表空间（table space）等内容。默认情况下，WAL 文件也会作为备份对象被包含。



使用 pg_basebackup 命令时，无需调用用于通知备份开始和结束的函数。此外，它也可以在远程执行。



执行该命令需要超级用户权限，或具有 REPLICATION 权限（用于将某些数据复制到其他数据库的权限）。



命令格式

```
pg_basebackup [选项]
```



**主要选项**

-   `-D 输出路径` 或 `--pgdata=输出路径`　**※必填**

    指定基础备份的输出目录路径。输出目录必须为空。

-   `-X s`（stream）或 `--wal-method=s`（stream）

    在备份的同时对 WAL 文件进行归档（流式归档）。这是默认设置。

    此方法会使用通过 max_wal_senders 参数设置的连接数中的 2 个连接。

-   `-X n`（none）或 `--wal-method=n`（none）

    不将 WAL 文件包含在备份对象中。

-   `-X f`（fetch）或 `--wal-method=f`（fetch）

    在备份的最后阶段收集 WAL 文件。

-   `-P` 或 `--progress`

    在备份过程中显示备份处理的进度。



**示例**

```bash
$ pg_basebackup -D /usr/local/var/bkup  ← 获取备份
$ ls /usr/local/var/bkup                ← 确认已获取备份

PG_VERSION  pg_ident.conf  pg_subtrans
backup_label  pg_logical  pg_tblspc
base  pg_multixact  pg_twophase
current_logfiles  pg_notify  pg_wal
global  pg_replslot  pg_xact
log  pg_serial  postgresql.auto.conf
pg_dynshmem  pg_snapshots  postgresql.conf
pg_hba.conf  pg_stat  pg_stat_tmp

$ ls /usr/local/var/bkup/pg_wal         ← 确认 WAL 文件也已备份

000000010000000000000002  archive_status

$ pg_basebackup -D /usr/local/var/bkup2 -X none  ← 获取不包含 WAL 文件的备份

NOTICE: WAL archiving is not enabled; you must ensure that all required WAL segments
are copied through another means to complete the backup

$ ls /usr/local/var/bkup2               ← 确认已获取备份

PG_VERSION  pg_ident.conf  pg_subtrans
backup_label  pg_logical  pg_tblspc
base  pg_multixact  pg_twophase
current_logfiles  pg_notify  pg_wal
global  pg_replslot  pg_xact
log  pg_serial  postgresql.auto.conf
pg_dynshmem  pg_snapshots  postgresql.conf
pg_hba.conf  pg_stat  pg_stat_tmp

$ ls /usr/local/var/bkup2/pg_wal        ← 确认未备份 WAL 文件

archive_status
```



##### 1.2.2.3 恢复操作

发生故障时进行，步骤如下：

1.  停止 PostgreSQL，并保存故障时的数据库集群
2.  还原已取得的基础备份
3.  删除已还原的数据库集群中的 $PGDATA/pg_wal 目录下的内容，然后将步骤 1）中备份下来的数据库集群中的 pg_wal 目录（未归档的 WAL）复制到 $PGDATA/pg_wal 目录中。
4.  在 postgresql.conf 中设置恢复相关参数
5.  创建空文件 recovery.signal 并放入 $PGDATA，然后启动 PostgreSQL



**补充说明：**

-   PostgreSQL 11 及之前版本使用 recovery.conf 配置恢复信息
-   PostgreSQL 12 起合并至 postgresql.conf
-   若 $PGDATA 下存在 recovery.signal 文件，启动 PostgreSQL 会进入恢复模式





**恢复相关参数：**



-   restore_command（必需）：恢复 WAL 的 shell 命令

    例如：`cp /archive/%f %p`

-   archive_cleanup_command：用于指定在删除不再需要的旧归档 WAL 文件时所执行的命令。

    %r 会被替换为执行恢复操作时所需的起始归档 WAL 文件名，早于此文件的归档 WAL 文件将被删除。

    例如：`pg_archivecleanup /archive %r`

-   recovery_end_command：恢复结束后执行的命令

-   recovery_target_time：用于指定数据库要恢复到的时间点。若不指定，则会恢复到最新的 WAL。

-   recovery_target_xid：用于指定数据库要恢复到的事务 ID（Transaction ID）。若不指定，则会恢复到最新的 WAL。



[LPI-JAPAN OSS-DB OSS-DB入門「第8回　バックアップ・リストア」：3.PITR](https://oss-db.jp/dojo/dojo_info_08)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「26.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）」：26.3.1. WALアーカイブの設定](https://www.postgresql.jp/document/14/html/continuous-archiving.html#BACKUP-ARCHIVING-WAL)



### 1.3 在线逻辑备份

下面介绍如何在线执行逻辑备份。

在线进行的逻辑备份是通过命令来执行的。像 postgresql.conf 等设置文件不包含在备份对象中。此外，备份期间不会阻塞其他用户对数据库的访问。



#### 1.3.1 使用 pg_dump 和 pg_dumpall 命令进行备份

##### 1.3.1.1 pg_dump 命令

用于执行逻辑备份的命令。

其特点如下：

-   以**数据库**为单位对数据库集群的数据进行备份
-   可仅备份数据或表定义，也可以以表为单位进行备份
-   也支持备份大对象（Large Object）
-   备份文件格式可通过选项指定为文本格式、定制格式（即二进制格式）或 tar 格式
-   使用文本格式备份的数据可通过 `psql` 命令还原，使用定制格式或 tar 格式备份的数据可通过 `pg_restore` 命令还原
-   执行时不需要特别的权限
-   可将数据库还原到备份获取时的状态



命令格式如下：

```
pg_dump [连接选项] [选项] [数据库名]
```



**主要连接选项**

如果未设置选项，将使用环境变量；如果环境变量未设置，则使用默认值。

| 选项              | 说明                                                   | 环境变量   | 默认值         |
| ----------------- | ------------------------------------------------------ | ---------- | -------------- |
| -U 用户名         | 指定连接时的数据库用户名                               | PGUSER     | 操作系统用户名 |
| -h 主机名或IP地址 | 指定连接目标的主机名或IP地址支持通过TCP/IP或UNIX域连接 | PGHOST     | 通过UNIX域连接 |
| -d 数据库名       | 指定连接目标的数据库名                                 | PGDATABASE | 数据库用户名   |
| -p 端口号         | 指定连接目标的端口号                                   | PGPORT     | 5432           |



**pg_dump 的主要选项**

| 选项                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| -F 格式<br>--format=格式   | 指定输出格式<br>省略时默认使用文本格式                       |
| p｜plain                   | 指定输出格式为文本格式（默认）                               |
| c｜custom                  | 指定输出格式为自定义格式（二进制格式）                       |
| t｜tar                     | 指定输出格式为tar格式                                        |
| -f 文件名<br>--file=文件名 | 指定备份输出文件的文件名<br>省略时输出到标准输出（即客户端终端） |



指定备份目标文件名时，也可以不使用 -f 选项，而是使用标准输出重定向。

对于 pg_dumpall 命令也同样适用。

例如：`-f file.dump → > file.dump`



**执行示例**

```bash
$ pg_dump -Fp -f file.dump test     ← 获取备份，输出格式为文本格式

$ file file.dump                    ← 确认文件格式的命令
file.dump: UTF-8 Unicode text       ← 确认输出为文本格式
```



##### 1.3.1.2 pg_dumpall 命令

用于执行逻辑备份的命令。

其特点如下：

-   除数据库数据外，**还可备份角色、表空间（用于存放数据库对象的空间）定义等**，涵盖整个数据库集群的所有数据

-   可通过选项指定仅备份全局对象

    （全局对象：对所有数据库通用的用户、表空间等信息）

-   备份文件格式为文本格式

-   由于不针对特定数据库，因此通常以超级用户身份执行

-   可将数据库还原到备份获取时的状态



命令格式如下：

```
pg_dumpall [连接选项] [选项]
```

※连接选项与 pg_dump 命令相同。



**pg_dumpall 的主要选项**

| 选项                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| -g                         | 指定仅备份全局对象                                           |
| -f 文件名<br>--file=文件名 | 指定备份输出文件名<br>如果省略则输出到标准输出（客户端屏幕） |



**执行示例**

```bash
$ pg_dumpall -U postgres -f file.dump
$ file file.dump    ←file：用于确认文件格式的命令
file.dump: UTF-8 Unicode C++ program text    ←text：确认以文本格式输出
```



#### 1.3.2 使用 psql 和 pg_restore 命令进行还原

逻辑备份时使用的 pg_dump 和 pg_dumpall 命令，与逻辑备份还原时使用的 psql 和 pg_restore 命令之间的对应关系如下所示：



**逻辑备份与还原所用命令的对应关系**

![image-20250722225716271](/Users/anonymouxc/Library/Application Support/typora-user-images/image-20250722225716271.png)



#### 1.3.2.1 psql **命令**

用于还原逻辑备份的命令。适用于使用文本格式备份的文件。



命令格式如下：

```
psql [连接选项] [选项] [数据库名]
```

※连接选项与 pg_dump 命令相同。



**psql 的主要选项**

| **选项**      | **说明**                             |
| ------------- | ------------------------------------ |
| -f 文件名     | 指定要还原的备份文件名               |
| --file=文件名 | 如果省略，则从标准输入中读取备份数据 |

在进行逻辑备份还原时，需事先创建还原目标数据库。



**示例**

```bash
$ pg_dump -f file.dump test     ← 以文本格式进行备份
$ dropdb test
$ createdb test
$ psql -f file.dump test
SET
SET
SET
SET
SET
SET
SET
SET
CREATE EXTENSION
COMMENT
SET
SET
SET
CREATE TABLE
ALTER TABLE
COPY 1
```



#### 1.3.2.2 pg_restore 命令

用于还原逻辑备份的命令。适用于非文本格式（如定制格式或 tar 格式）备份的文件。

可同时还原大对象（用于存储大型二进制或文本数据）和序列值（自动生成的连续编号）。



命令格式如下：

```
pg_restore [连接选项] [选项] [文件名]
```

※连接选项与 pg_dump 命令相同。



**pg_restore 的主要选项**

| 选项                             | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| -d 数据库名<br>--dbname=数据库名 | 指定还原目标的数据库名称<br>省略时输出到标准输出，以文本格式显示 SQL 语句 |
| -c 或 --clean                    | 在还原前删除已有数据库对象                                   |
| -j 作业数<br>--jobs=作业数       | 指定并发执行的还原作业数                                     |
| -1<br>--single-transaction       | 将整个还原处理作为一个事务执行                               |



**执行示例**

```bash
$ pg_dump -Fc db002 > db002.bak    ← 以自定义格式（二进制）备份
$ dropdb db002
$ createdb db002
$ pg_restore -d db002 db002.bak
```



[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「pg_dump」](https://www.postgresql.jp/document/14/html/app-pgdump.html)

[Let’s Postgres「論理バックアップ（pg_dump と pg_dumpall）」：3.1 pg_dumpによるバックアップ](https://lets.postgresql.jp/documents/technical/backup/2)

[LPI-JAPAN OSS-DB OSS-DB入門「第8回　バックアップ・リストア」：2.pg_dump, pg_dumpall, pg_restoreコマンド](https://oss-db.jp/dojo/dojo_info_08)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「pg_restore」：オプション](https://www.postgresql.jp/document/14/html/app-pgrestore.html#APP-PGRESTORE-OPTIONS)



## 2. 复制（Replication）

复制是指在多个服务器之间复制和同步数据的机制。通过这一机制可以实现高可用性和负载均衡。

PostgreSQL 提供两种复制功能，其主要特征如下：



### 2.1 流复制（Streaming Replication）

-   **服务器结构**：主节点（复制源）与备节点（复制目标）
-   **复制对象**：复制的是所有数据库
-   **数据同步方式**：将主节点生成的 WAL 传送至备节点并应用
-   **限制**：不同主版本或不同平台之间无法使用
-   **备节点状态**：接收方服务器为只读，不能执行数据新增或更新操作
-   **配置要求**：构建环境时需在 postgresql.conf 文件中将 wal_level 设置为 replica 或 logical

![image-20250722225403872](/Users/anonymouxc/Library/Application Support/typora-user-images/image-20250722225403872.png)

流复制会将整个数据库完整复制和同步，主要用于实现负载均衡或在发生故障时进行故障转移（failover：主数据库出现故障后，切换到备节点继续运行）。



### 2.2 逻辑复制（Logical Replication）

-   **服务器结构**：发布端（复制源）与订阅端（复制目标）
-   **复制对象**：可指定特定的表或特定操作作为复制对象
-   **数据同步方式**：从发布端的 WAL 中提取指定的操作信息，发送至订阅端并应用
-   **适用范围**：支持不同主版本或不同平台之间的复制
-   **订阅端能力**：接收端服务器可以执行数据新增与更新操作
-   **配置要求**：构建环境时需在 postgresql.conf 文件中将 wal_level 设置为 logical

![image-20250722225437882](/Users/anonymouxc/Library/Application Support/typora-user-images/image-20250722225437882.png)

逻辑复制适用于只需复制特定表或操作而非整个数据库集群的场景。

同一个服务器可以拥有多个订阅，因此也适用于将多个数据库的数据汇集到一个数据库中。

此外，逻辑复制支持不同主版本和平台之间的使用，常用于 PostgreSQL 主版本升级或跨平台数据迁移等场景。



[Let’s Postgres「ストリーミング・レプリケーション」](https://lets.postgresql.jp/documents/technical/replication/1)



#### 2.2.1 发布（Publication）

PostgreSQL 提供的逻辑复制功能之一是，通过在发布端服务器（Publisher）创建“发布”（即复制目标表或操作的定义信息），在订阅端服务器（Subscriber）创建“订阅”（即连接信息及复制内容的定义）来实现数据复制。



用于管理发布的 SQL 命令有：CREATE PUBLICATION / ALTER PUBLICATION / DROP PUBLICATION

#### 2.2.1.1 CREATE PUBLICATION

用于创建发布的命令。

语法如下：

```
CREATE PUBLICATION 发布名称 [ FOR TABLE 表名[, 表名...] | FOR ALL TABLES ] [ WITH ( 参数 ) ]
```

**指定复制对象**

-   FOR TABLE 表名：指定要复制的表。可以用逗号分隔指定多个表。
-   FOR ALL TABLES：将数据库中的所有表作为复制对象。

※在逻辑复制中，可作为复制对象的仅限于普通表和分区表。视图、物化视图、序列、分区父表等不能成为复制对象。



**WITH 子句**

-   publish：指定希望复制的操作。可指定的操作包括 INSERT、UPDATE、DELETE、TRUNCATE。默认会复制全部操作。



创建后的发布可以通过系统目录 pg_publication 或 psql 命令 \dRp（显示所有发布）来查看。

发布目标表可通过 pg_publication_tables 查看。



**示例**

```sql
repdb1=# CREATE PUBLICATION pub01 FOR TABLE tbl01 WITH (publish = 'insert');
CREATE PUBLICATION         -- ↑ 创建发布 pub01，仅对 tbl01 的 insert 操作进行复制
repdb1=# \dRp
                                 List of publications
 Name  |  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root 
--------+----------+------------+---------+---------+---------+-----------+----------
 pub01 | postgres | f          | t       | f       | f       | f
(1 row)

repdb1=# SELECT * FROM pg_publication_tables;
 pubname | schemaname | tablename 
---------+-------------+-----------
 pub01   | public      | tbl01
(1 row)
```



发布名在数据库内必须唯一。若与已存在的发布名重复，会发生错误。



#### 2.2.1.2 ALTER PUBLICATION

用于修改发布定义的命令。

语法如下：

-   添加复制对象表：

```
ALTER PUBLICATION 发布名称 ADD TABLE 表名[, 表名...]
```



-   删除复制对象表：

```
ALTER PUBLICATION 发布名称 DROP TABLE 表名[, 表名...]
```



-   修改发布参数：

```
ALTER PUBLICATION 发布名称 SET ( 参数 )
```



**示例**

```sql
repdb1=# \dRp
                                 List of publications
 Name  |  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root 
--------+----------+------------+---------+---------+---------+-----------+----------
 pub01 | postgres | f          | t       | f       | f       | f
(1 row)

repdb1=# SELECT * FROM pg_publication_tables;
 pubname | schemaname | tablename 
---------+-------------+-----------
 pub01   | public      | tbl01
(1 row)

repdb1=# ALTER PUBLICATION pub01 ADD TABLE tbl02;  ←向 pub01 添加一个复制目标表 tbl02
ALTER PUBLICATION
repdb1=# ALTER PUBLICATION pub01 SET (publish = 'insert, update');
ALTER PUBLICATION         -- ↑更改 pub01 的复制操作为 insert 和 update
repdb1=# \dRp
                                 List of publications
 Name  |  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root 
--------+----------+------------+---------+---------+---------+-----------+----------
 pub01 | postgres | f          | t       | t       | f       | f
(1 row)

repdb1=# SELECT * FROM pg_publication_tables;
 pubname | schemaname | tablename 
---------+-------------+-----------
 pub01   | public      | tbl01
 pub01   | public      | tbl02
(2 rows)
```



##### 2.2.1.3 DROP PUBLICATION

用于删除发布的命令。

语法如下：

```
DROP PUBLICATION 发布名称
```



**示例**

```sql
repdb1=# \dRp
                                 List of publications
 Name  |  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root 
--------+----------+------------+---------+---------+---------+-----------+----------
 pub01 | postgres | f          | t       | t       | f       | f
(1 row)
repdb1=# DROP PUBLICATION pub01;    ← 删除发布 pub01
DROP PUBLICATION
repdb1=# \dRp
                                 List of publications
 Name  |  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root 
--------+----------+------------+---------+---------+---------+-----------+----------
(0 rows)
```



#### 2.2.2 订阅（Subscription）

用于管理订阅的 SQL 命令有：CREATE SUBSCRIPTION / ALTER SUBSCRIPTION / DROP SUBSCRIPTION



#### 2.2.2.1 CREATE SUBSCRIPTION

用于创建订阅的命令。

语法如下：

```
CREATE SUBSCRIPTION 订阅名称 CONNECTION '连接信息' PUBLICATION 发布名称[, 发布名称...] [ WITH ( 参数 ) ]
```

**发布端连接信息**

用于连接发布端的 CONNECTION 参数中应指定以下信息：

-   host：主机名
-   port：端口号
-   user：PostgreSQL 用户名
-   dbname：发布端数据库名



**WITH 子句**

-   enabled：是否在创建订阅时立即开始复制。默认为 true。设为 false 时，仅创建订阅不开始复制。
-   copy_data：是否在复制开始时复制发布端表中的现有数据。默认为 true。

创建的订阅可以通过系统目录 pg_subscription 或 psql 命令 \dRs（显示所有订阅，(R)eplication (S)ubscription）查看。

```sql
repdb2=# CREATE SUBSCRIPTION sub01 CONNECTION 'host=localhost port=5432 user=postgres dbname=repdb1' PUBLICATION pub01 WITH (enabled = false);      ←创建订阅 sub01，用于订阅 repdb1 上的发布 pub01
NOTICE:  created replication slot "sub01" on publisher
                           -- ↑ 发布端自动创建复制槽
CREATE SUBSCRIPTION
repdb2=# \dRs
                 List of subscriptions
 Name  |  Owner   | Enabled |   Publication    
--------+----------+---------+------------------
 sub01 | postgres | f       | {pub01}
(1 row)
```



订阅名在数据库中必须唯一，重复会报错。

执行 CREATE SUBSCRIPTION 时，会自动在发布端创建一个复制槽（用于管理数据同步的机制）。



##### 2.2.2.2 ALTER SUBSCRIPTION

用于修改订阅定义的命令。

语法如下：

-   修改连接信息：

```
ALTER SUBSCRIPTION 订阅名称 CONNECTION '连接信息'
```



-   添加发布对象：

```
ALTER SUBSCRIPTION 订阅名称 ADD PUBLICATION 发布名称
```



-   删除发布对象：

```
ALTER SUBSCRIPTION 订阅名称 DROP PUBLICATION 发布名称
```



-   同步新增的复制表信息到订阅端：

```
ALTER SUBSCRIPTION 订阅名称 REFRESH PUBLICATION [WITH ( 参数 )]
```



-   启用订阅：

```
ALTER SUBSCRIPTION 订阅名称 ENABLE
```



-   禁用订阅：

```
ALTER SUBSCRIPTION 订阅名称 DISABLE
```



-   修改订阅参数：

```
ALTER SUBSCRIPTION 订阅名称 SET ( 参数 )
```



**示例**

```sql
repdb2=# \dRs
                 List of subscriptions
 Name  |  Owner   | Enabled |   Publication    
--------+----------+---------+------------------
 sub01 | postgres | f       | {pub01}
(1 row)
repdb2=# ALTER SUBSCRIPTION sub01 ENABLE;     ←启用订阅 sub01
ALTER SUBSCRIPTION
repdb2=# ALTER SUBSCRIPTION sub01 ADD PUBLICATION pub02;    ← 为 sub01 添加发布 pub02
ALTER SUBSCRIPTION
repdb2=# \dRs
                 List of subscriptions
 Name  |  Owner   | Enabled |     Publication     
--------+----------+---------+----------------------
 sub01 | postgres | t       | {pub01,pub02}
(1 row)
```



##### 2.2.2.3 DROP SUBSCRIPTION

用于删除订阅的命令。

语法如下：

```
DROP SUBSCRIPTION 订阅名称
```



**示例**

```sql
repdb2=# \dRs
                 List of subscriptions
 Name  |  Owner   | Enabled |     Publication     
--------+----------+---------+----------------------
 sub01 | postgres | t       | {pub01,pub02}
(1 row)

repdb2=# DROP SUBSCRIPTION sub01;          ← 删除订阅 sub01
NOTICE:  dropped replication slot "sub01" on publisher
DROP SUBSCRIPTION          -- ↑与 sub01 对应的复制槽也被删除
repdb2=# \dRs
                 List of subscriptions
 Name  |  Owner   | Enabled |     Publication     
--------+----------+---------+----------------------
(0 rows)
```



[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「CREATE PUBLICATION」](https://www.postgresql.jp/document/14/html/sql-createpublication.html)

[日本PostgreSQLユーザ会 PostgreSQL 14.5文書「CREATE SUBSCRIPTION」](https://www.postgresql.jp/document/14/html/sql-createsubscription.html)





