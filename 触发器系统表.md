表pg_triggers和 information_schema.triggers的区别



好问题 👍，这两个表在 PostgreSQL 里确实都能看到 **触发器 (trigger)** 信息，但它们的定位和内容不一样。



------





## **1.** 

## **pg_trigger (系统目录表)**





-   属于 **PostgreSQL 内部系统目录**，存放触发器的底层定义。
-   直接由数据库内核维护。
-   里面的字段比较底层、偏内部实现。





常见字段：



-   tgname：触发器名称
-   tgrelid：触发器所在表的 OID
-   tgfoid：触发函数的 OID
-   tgtype：触发器类型（BEFORE/AFTER/INSTEAD OF + 行级/语句级）
-   tgenabled：是否启用
-   tgisinternal：是否为系统内部触发器
-   tgdeferrable / tginitdeferred：延迟触发属性





👉 特点：



-   信息 **最全**，包括内部触发器（比如外键约束生成的触发器）。
-   但字段内容对一般用户来说太底层，需要和其他系统表（pg_class、pg_proc）联查才能看懂。





------





## **2.** 

## **information_schema.triggers (信息模式视图)**





-   属于 **标准 SQL 信息模式 (information_schema)**。
-   是基于 pg_trigger 等系统表封装出来的 **视图**。
-   面向普通用户，结构更符合 SQL 标准。





常见字段：



-   trigger_name：触发器名
-   event_manipulation：触发事件（INSERT/UPDATE/DELETE/TRUNCATE）
-   event_object_table：作用的表名
-   action_timing：BEFORE / AFTER / INSTEAD OF
-   action_statement：触发时执行的语句（调用函数）
-   trigger_schema：触发器所在 schema





👉 特点：



-   信息 **更直观**，用户友好。
-   只显示 **用户定义的触发器**（不包括系统内部触发器）。
-   兼容 SQL 标准，在不同数据库系统里查询方式基本一致。





------





## **3. 对比总结**



| **特性** | pg_trigger                         | information_schema.triggers |
| -------- | ---------------------------------- | --------------------------- |
| 类型     | 系统目录表（内部存储）             | 视图（基于系统表封装）      |
| 数据范围 | 所有触发器（含系统内部）           | 仅用户定义触发器            |
| 字段内容 | OID、函数 ID、触发器类型等底层信息 | 符合 SQL 标准的直观信息     |
| 可读性   | 偏底层，不直观                     | 用户友好，跨数据库通用      |
| 使用场景 | DBA/开发调试、系统级分析           | 普通用户查询触发器定义      |



------



📌 **一句话总结**：



-   pg_trigger 是 **PostgreSQL 内部原始表**，信息全面但底层；
-   information_schema.triggers 是 **标准化视图**，适合普通用户查看触发器定义。





------



要不要我帮您写一段 **SQL 示例**，对同一个触发器分别查询 pg_trigger 和 information_schema.triggers，让您直观对比结果？